diff -uprN a/src/stream/ngx_stream_ssl_preread_module.c b/src/stream/ngx_stream_ssl_preread_module.c
--- a/src/stream/ngx_stream_ssl_preread_module.c
+++ b/src/stream/ngx_stream_ssl_preread_module.c
@@ -6,8 +6,23 @@
 
 #include <ngx_config.h>
 #include <ngx_core.h>
+#include <ngx_md5.h>
 #include <ngx_stream.h>
 
+#include <openssl/tls1.h>
+#include <math.h>
+
+static const unsigned short GREASE_BEGIN = 0x0a0a;
+static const unsigned short GREASE_BITMASK = 0x0f0f;
+
+static int is_ext_greased(int id)
+{
+    if (GREASE_BEGIN == (id & GREASE_BITMASK)) {
+        return 1;
+    }
+
+    return 0;
+}
 
 typedef struct {
     ngx_flag_t      enabled;
@@ -27,6 +42,20 @@ typedef struct {
     ngx_log_t      *log;
     ngx_pool_t     *pool;
     ngx_uint_t      state;
+
+    int             ssl_version;
+    unsigned short *ciphers;
+    size_t          ciphers_len;
+    unsigned short *extensions;
+    size_t          extensions_len;
+    unsigned short  *curves;
+    size_t          curves_len;
+    unsigned char  *point_formats;
+    size_t          point_formats_len;
+
+    ngx_str_t       ja3_str;
+    ngx_str_t       ja3_md5;
+    
 } ngx_stream_ssl_preread_ctx_t;
 
 
@@ -39,6 +68,10 @@ static ngx_int_t ngx_stream_ssl_preread_
     ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);
 static ngx_int_t ngx_stream_ssl_preread_alpn_protocols_variable(
     ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);
+static ngx_int_t ngx_stream_ssl_preread_ja3_hash_variable(
+    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);
+static ngx_int_t ngx_stream_ssl_preread_ja3_variable(
+    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);
 static ngx_int_t ngx_stream_ssl_preread_add_variables(ngx_conf_t *cf);
 static void *ngx_stream_ssl_preread_create_srv_conf(ngx_conf_t *cf);
 static char *ngx_stream_ssl_preread_merge_srv_conf(ngx_conf_t *cf, void *parent,
@@ -98,9 +131,18 @@ static ngx_stream_variable_t  ngx_stream
     { ngx_string("ssl_preread_alpn_protocols"), NULL,
       ngx_stream_ssl_preread_alpn_protocols_variable, 0, 0, 0 },
 
+    { ngx_string("ssl_preread_ja3"), NULL,
+      ngx_stream_ssl_preread_ja3_variable, 0, 0, 0 },
+
+    { ngx_string("ssl_preread_ja3_hash"), NULL,
+      ngx_stream_ssl_preread_ja3_hash_variable, 0, 0, 0 },
+
       ngx_stream_null_variable
 };
 
+static size_t get_int_len(int value) {
+    return (value == 0 ? 1 : (int)(log10(value) + 1));
+}
 
 static ngx_int_t
 ngx_stream_ssl_preread_handler(ngx_stream_session_t *s)
@@ -112,6 +154,14 @@ ngx_stream_ssl_preread_handler(ngx_strea
     ngx_stream_ssl_preread_ctx_t       *ctx;
     ngx_stream_ssl_preread_srv_conf_t  *sscf;
 
+    ngx_str_t cs_str = ngx_null_string;
+    ngx_str_t ext_str = ngx_null_string;
+    ngx_str_t curve_str = ngx_null_string;
+    ngx_str_t ecpf_str = ngx_null_string;
+    size_t i, str_pos, cs_pos = 0, ext_pos = 0, curve_pos = 0, ecpf_pos = 0;
+    size_t str_len, ssl_ver_len = 0, cs_len = 0, ext_len = 0, curve_len = 0;
+    unsigned short cs, ext_type, curve, ecpf;
+
     c = s->connection;
 
     ngx_log_debug0(NGX_LOG_DEBUG_STREAM, c->log, 0, "ssl preread handler");
@@ -187,11 +237,110 @@ ngx_stream_ssl_preread_handler(ngx_strea
             return NGX_DECLINED;
         }
 
+        if (ctx->ja3_str.data == NULL || ctx->ja3_str.len == 0) {
+            ssl_ver_len = get_int_len(ctx->ssl_version);
+
+            str_len = ssl_ver_len;
+            str_len++; // comma
+
+            cs_str.data = ngx_pnalloc(ctx->pool, ctx->ciphers_len * 6 - 1);
+            for (i = 0; i < ctx->ciphers_len; i++) {
+                cs = htons(ctx->ciphers[i]);
+                cs_len = get_int_len(cs);
+                ngx_sprintf(cs_str.data + cs_pos, "%d", cs);
+                
+                cs_pos += cs_len;
+                if (i != ctx->ciphers_len - 1) {
+                    cs_str.data[cs_pos] = '-';
+                    cs_pos++;
+                }
+
+            }
+            cs_str.len = cs_pos;
+
+            str_len += cs_str.len;
+            str_len++; // comma
+
+            ext_str.data = ngx_pnalloc(ctx->pool, ctx->extensions_len * 6 - 1);
+            for (i = 0; i < ctx->extensions_len / 2; i++) {
+                ext_type = ctx->extensions[i];
+                ext_len = get_int_len(ext_type);
+                ngx_sprintf(ext_str.data + ext_pos, "%d", ext_type);
+                
+                ext_pos += ext_len;
+                if (i != ctx->extensions_len / 2 - 1) {
+                    ext_str.data[ext_pos] = '-';
+                    ext_pos++;
+                }
+
+            }
+            ext_str.len = ext_pos;
+
+            str_len += ext_str.len;
+            str_len++; // comma
+
+            curve_str.data = ngx_pnalloc(ctx->pool, ctx->curves_len * 6 - 1);
+            for (i = 0; i < ctx->curves_len / 2; i++) {
+                curve = ctx->curves[i];
+                curve_len = get_int_len(curve);
+                ngx_sprintf(curve_str.data + curve_pos, "%d", curve);
+                
+                curve_pos += curve_len;
+                if (i != ctx->curves_len / 2 - 1) {
+                    curve_str.data[curve_pos] = '-';
+                    curve_pos++;
+                }
+
+            }
+
+            curve_str.len = curve_pos;
+
+            str_len += curve_str.len;
+            str_len++; // comma
+
+            ecpf_str.data = ngx_pnalloc(ctx->pool, ctx->point_formats_len);
+            ecpf = ctx->point_formats[ctx->point_formats_len - 1];
+            ngx_sprintf(ecpf_str.data + ecpf_pos, "%d", ecpf);
+            ecpf_pos++;
+            ecpf_str.len = ecpf_pos;
+
+            str_len += ecpf_str.len;
+
+
+            ctx->ja3_str.data = ngx_pnalloc(ctx->pool, str_len + 1);
+
+            ngx_snprintf(ctx->ja3_str.data, ssl_ver_len, "%d", ctx->ssl_version);
+            str_pos = ssl_ver_len;
+            ctx->ja3_str.data[str_pos] = ',';
+            str_pos++;
+
+            ngx_memcpy(ctx->ja3_str.data + str_pos, cs_str.data, cs_str.len);
+            str_pos += cs_str.len;
+            ctx->ja3_str.data[str_pos] = ',';
+            str_pos++;
+
+            ngx_memcpy(ctx->ja3_str.data + str_pos, ext_str.data, ext_str.len);
+            str_pos += ext_str.len;
+            ctx->ja3_str.data[str_pos] = ',';
+            str_pos++;
+
+            ngx_memcpy(ctx->ja3_str.data + str_pos, curve_str.data, curve_str.len);
+            str_pos += curve_str.len;
+            ctx->ja3_str.data[str_pos] = ',';
+            str_pos++;
+
+            ngx_memcpy(ctx->ja3_str.data + str_pos, ecpf_str.data, ecpf_str.len);
+            str_pos += ecpf_str.len;
+
+            ctx->ja3_str.len = str_len;
+        }
+
         if (rc != NGX_AGAIN) {
             return rc;
         }
 
         p += len;
+
     }
 
     ctx->pos = p;
@@ -206,6 +355,9 @@ ngx_stream_ssl_preread_parse_record(ngx_
 {
     size_t   left, n, size, ext;
     u_char  *dst, *p;
+    size_t i = 0, j = 0, len = 0;
+    unsigned short tmp = 0;
+    u_char  *p_ext, *p_tmp;
 
     enum {
         sw_start = 0,
@@ -274,12 +426,15 @@ ngx_stream_ssl_preread_parse_record(ngx_
             dst = ctx->version;
             size = 2;
             left = (p[1] << 16) + (p[2] << 8) + p[3];
+
+            ctx->ssl_version = (pos[0] << 8) + pos[1];
             break;
 
         case sw_version:
             state = sw_random;
             dst = NULL;
             size = 32;
+            
             break;
 
         case sw_random:
@@ -298,12 +453,30 @@ ngx_stream_ssl_preread_parse_record(ngx_
             state = sw_cs_len;
             dst = p;
             size = 2;
+            ctx->ciphers_len = (pos[0] << 8) + pos[1];
+            ctx->ciphers_len /= 2;
             break;
 
         case sw_cs_len:
             state = sw_cs;
             dst = NULL;
             size = (p[0] << 8) + p[1];
+
+            len = ctx->ciphers_len * sizeof(unsigned short);
+            ctx->ciphers = ngx_pnalloc(ctx->pool, len);
+
+            if (ctx->ciphers == NULL) {
+                return NGX_DECLINED;
+            }
+
+            /* Exclude GREASE cipher suites */
+            for (i = 0; i < ctx->ciphers_len; ++i) {
+                memcpy(&tmp, pos + i * sizeof(uint16_t), sizeof(uint16_t));
+                if (!is_ext_greased(tmp)) {
+                    ctx->ciphers[j++] = tmp;
+                }
+            }
+
             break;
 
         case sw_cs:
@@ -327,6 +500,9 @@ ngx_stream_ssl_preread_parse_record(ngx_
             state = sw_ext;
             dst = p;
             size = 2;
+
+            ctx->extensions_len = (pos[0] << 8) + pos[1];
+            
             break;
 
         case sw_ext:
@@ -337,6 +513,51 @@ ngx_stream_ssl_preread_parse_record(ngx_
             state = sw_ext_header;
             dst = p;
             size = 4;
+
+            if (ctx->extensions == NULL) {
+                ctx->extensions = ngx_pnalloc(ctx->pool, ctx->extensions_len);
+
+                j = 0;
+                p_ext = pos;
+                while (p_ext < last) {
+                    tmp = (p_ext[0] << 8) + p_ext[1];
+                    if (!is_ext_greased(tmp)) {
+                        ctx->extensions[j++] = tmp;
+                    }
+                    p_ext += 2;
+                    len = (p_ext[0] << 8) + p_ext[1];
+                    p_ext += 2;
+
+                    if (tmp == TLSEXT_TYPE_supported_groups) {
+                        ctx->curves_len = (p_ext[0] << 8) + p_ext[1];
+                        ctx->curves = ngx_pnalloc(ctx->pool, ctx->curves_len);
+                        p_tmp = p_ext;
+                        p_tmp += 2;
+                        for (i = 0; i < ctx->curves_len / 2; i++) {
+                            tmp = (p_tmp[i * 2] << 8) + p_tmp[i * 2 + 1];
+                            if (!is_ext_greased(tmp)) {
+                                ctx->curves[i] = tmp;
+                            }
+                        }
+                    }
+
+                    if (tmp == TLSEXT_TYPE_ec_point_formats) {
+                        ctx->point_formats_len = p_ext[0];
+                        ctx->point_formats = ngx_pnalloc(ctx->pool, ctx->point_formats_len);
+                        p_tmp = p_ext;
+                        p_tmp += ctx->point_formats_len;
+                        
+                        tmp = p_tmp[ctx->point_formats_len - 1];
+                        if (!is_ext_greased(tmp)) {
+                            ctx->point_formats[i] = tmp;
+                        }
+                    }
+
+                    p_ext += len;
+                }
+                ctx->extensions_len = j * 2;
+            }
+
             break;
 
         case sw_ext_header:
@@ -597,6 +818,61 @@ ngx_stream_ssl_preread_alpn_protocols_va
     return NGX_OK;
 }
 
+static ngx_int_t
+ngx_stream_ssl_preread_ja3_hash_variable(ngx_stream_session_t *s,
+    ngx_variable_value_t *v, uintptr_t data)
+{
+    ngx_stream_ssl_preread_ctx_t  *ctx;
+    ngx_md5_t                      md5_ctx;
+    u_char                         hash[16] = {0};
+
+    ctx = ngx_stream_get_module_ctx(s, ngx_stream_ssl_preread_module);
+
+    if (ctx == NULL) {
+        v->not_found = 1;
+        return NGX_OK;
+    }
+
+    v->data = ngx_pcalloc(ctx->pool, 32);
+
+    if (v->data == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_md5_init(&md5_ctx);
+    ngx_md5_update(&md5_ctx, ctx->ja3_str.data, ctx->ja3_str.len);
+    ngx_md5_final(hash, &md5_ctx);
+    ngx_hex_dump(v->data, hash, 16);
+    v->len = 32;
+
+    v->valid = 1;
+    v->no_cacheable = 0;
+    v->not_found = 0;
+
+    return NGX_OK;
+}
+
+static ngx_int_t
+ngx_stream_ssl_preread_ja3_variable(ngx_stream_session_t *s,
+    ngx_variable_value_t *v, uintptr_t data)
+{
+    ngx_stream_ssl_preread_ctx_t  *ctx;
+
+    ctx = ngx_stream_get_module_ctx(s, ngx_stream_ssl_preread_module);
+
+    if (ctx == NULL) {
+        v->not_found = 1;
+        return NGX_OK;
+    }
+
+    v->valid = 1;
+    v->no_cacheable = 0;
+    v->not_found = 0;
+    v->len = ctx->ja3_str.len;
+    v->data = ctx->ja3_str.data;
+
+    return NGX_OK;
+}
 
 static ngx_int_t
 ngx_stream_ssl_preread_add_variables(ngx_conf_t *cf)
